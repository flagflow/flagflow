/* eslint-disable unicorn/prefer-single-call */
import { sortMapByKey, sortObjectByKey } from '$lib/objectEx';
import { capitalizeWords } from '$lib/stringEx';
import type { EtcdFlagObject } from '$types/etcd/flagObject';

const ROOT_TYPE_NAME = 'FlagFlow';
const generateGroupCode = (
	groupName: string,
	groupFlags: Record<string, EtcdFlagObject | string>
): string[] => {
	const tsFileLines: string[] = [];

	const typeName = ROOT_TYPE_NAME + (groupName ? `__${capitalizeWords(groupName, '__')}` : '');
	tsFileLines.push(`export type ${typeName} = {`);
	for (const [flagName, flag] of Object.entries(sortObjectByKey(groupFlags))) {
		if (typeof flag === 'string') {
			const subTypeName = ROOT_TYPE_NAME + (flag ? `__${capitalizeWords(flag, '__')}` : '');
			tsFileLines.push(`\treadonly ${flagName}: ${subTypeName};`);
		} else {
			//tsFileLines.push(`\t/**`);
			//if (flag.description) tsFileLines.push(`\t* ${flag.description}`);
			//tsFileLines.push(`\t* @default ${flag.defaultValue}`);
			//tsFileLines.push(`\t*/`);
			const type = flag.getTypescriptType();
			tsFileLines.push(`\treadonly ${flagName}: ${type};`);
		}
	}
	tsFileLines.push(`};`, '');

	return tsFileLines;
};

export const generateTSFileContent = (
	flags: Record<string, EtcdFlagObject>,
	groupTypeHash: Map<string, string>
): string => {
	const groups: Map<string, Record<string, EtcdFlagObject | string>> = new Map();

	// Generate groups
	const startTime = Date.now();
	for (const [key, flag] of Object.entries(flags)) {
		const keyParts = key.split('/');
		const name = keyParts.at(-1);
		const groupParts = keyParts.slice(0, -1);
		if (!name) continue;

		const groupName = groupParts.join('__');
		if (!groups.has(groupName)) groups.set(groupName, {});
		groups.get(groupName)![name] = flag;
		if (groupParts.length > 0) {
			const subGroupName = groupParts.slice(0, -1).join('__');
			if (!groups.has(subGroupName)) groups.set(subGroupName, {});
			groups.get(subGroupName)![groupParts.at(-1) || ''] = groupParts.join('__');
		}
	}
	const elapsedTime = Date.now() - startTime;

	// Generate TypeScript file content
	const tsFileContent: string[] = [];
	tsFileContent.push(
		'// This file is auto-generated by FlagFlow. Do not edit manually!',
		`// Created at: ${new Date().toISOString()} in ${elapsedTime}ms`
	);

	tsFileContent.push('', '', '// Group types');
	for (const [groupName, groupFlags] of sortMapByKey(groups).entries())
		tsFileContent.push(...generateGroupCode(groupName, groupFlags));

	tsFileContent.push('', '', '// Group hash checksums');
	for (const [groupName, groupHash] of groupTypeHash.entries()) {
		const typeName = ROOT_TYPE_NAME + (groupName ? `__${capitalizeWords(groupName, '__')}` : '');
		tsFileContent.push(`export const HASH_${typeName.toLocaleUpperCase()} = '${groupHash}';`);
	}

	tsFileContent.push('', '', '// Client type descriptors');
	tsFileContent.push('export type FlagFlow_DescriptorTypeMap = {');
	for (const groupName of groupTypeHash.keys().toArray().sort()) {
		const typeKey = (groupName || '#root').replaceAll('__', '/');
		const typeName = ROOT_TYPE_NAME + (groupName ? `__${capitalizeWords(groupName, '__')}` : '');
		tsFileContent.push(`\t'${typeKey}': ${typeName};`);
	}
	tsFileContent.push('};');

	tsFileContent.push(`
export const flagFlow_Descriptors: {
	[K in keyof FlagFlow_DescriptorTypeMap]: {
		hash: string;
		uri: string;
	}
} = {`);
	for (const groupName of groupTypeHash.keys().toArray().sort()) {
		const typeUri = groupName.replaceAll('__', '/');
		const typeKey = (groupName || '#root').replaceAll('__', '/');
		const typeName = ROOT_TYPE_NAME + (groupName ? `__${capitalizeWords(groupName, '__')}` : '');
		tsFileContent.push(`\t'${typeKey}': {`);
		tsFileContent.push(`\t\thash: HASH_${typeName.toUpperCase()},`);
		tsFileContent.push(`\t\turi: '${typeUri ? '/' + typeUri : ''}',`);
		tsFileContent.push(`\t},`);
	}
	tsFileContent.push(`} as const;`, '');

	return tsFileContent.join('\n');
};
