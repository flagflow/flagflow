/* eslint-disable unicorn/prefer-single-call */
import {
	flagTypescriptDefaultValue,
	flagTypescriptType,
	flagTypescriptZodMethod
} from '$lib/flagHandler/flagTypescript';
import { sortMapByKey, sortObjectByKey } from '$lib/objectEx';
import { capitalizeWords } from '$lib/stringEx';
import type { PersistentFlag } from '$types/persistent';

const ROOT_TYPE_NAME = 'FlagFlow';
const generateGroupTypeCode = (
	groupName: string,
	groupFlags: Record<string, PersistentFlag | string>
): string[] => {
	const tsFileLines: string[] = [];

	const typeName = ROOT_TYPE_NAME + (groupName ? `__${capitalizeWords(groupName, '__')}` : '');
	tsFileLines.push(`export type ${typeName} = {`);
	for (const [flagName, flag] of Object.entries(sortObjectByKey(groupFlags))) {
		if (typeof flag === 'string') {
			const subTypeName = ROOT_TYPE_NAME + (flag ? `__${capitalizeWords(flag, '__')}` : '');
			tsFileLines.push(`\treadonly ${flagName}: ${subTypeName};`);
		} else {
			tsFileLines.push(`\t/**`);
			if (flag.description) tsFileLines.push(`\t* ${flag.description}`);
			tsFileLines.push(`\t* @default ${flagTypescriptDefaultValue(flag)}`);
			tsFileLines.push(`\t*/`);
			tsFileLines.push(`\treadonly ${flagName}: ${flagTypescriptType(flag)};`);
		}
	}
	tsFileLines.push(`};`, '');

	return tsFileLines;
};

const ROOT_DEFAULTOBJECT_NAME = 'defaultFlagFlow';
const generateGroupDefaultObjectCode = (
	groupName: string,
	groupFlags: Record<string, PersistentFlag | string>
): string[] => {
	const tsFileLines: string[] = [];

	const typeName = ROOT_TYPE_NAME + (groupName ? `__${capitalizeWords(groupName, '__')}` : '');
	const constName =
		ROOT_DEFAULTOBJECT_NAME + (groupName ? `__${capitalizeWords(groupName, '__')}` : '');
	tsFileLines.push(`export const ${constName}: ${typeName} = {`);
	for (const [flagName, flag] of Object.entries(sortObjectByKey(groupFlags))) {
		if (typeof flag === 'string') {
			const subConstTypeName =
				ROOT_DEFAULTOBJECT_NAME + (flag ? `__${capitalizeWords(flag, '__')}` : '');
			tsFileLines.push(`\t${flagName}: ${subConstTypeName},`);
		} else {
			tsFileLines.push(`\t${flagName}: ${flagTypescriptDefaultValue(flag)},`);
		}
	}
	tsFileLines.push(`};`, '');

	return tsFileLines;
};

const ROOT_ZOD_NAME = 'FlagFlow';
const generateGroupZodCode = (
	groupName: string,
	groupFlags: Record<string, PersistentFlag | string>
): string[] => {
	const tsFileLines: string[] = [];

	const constName = ROOT_ZOD_NAME + (groupName ? `__${capitalizeWords(groupName, '__')}` : '');
	tsFileLines.push(`export const ${constName} = z.object({`);
	for (const [flagName, flag] of Object.entries(sortObjectByKey(groupFlags))) {
		if (typeof flag === 'string') {
			const subConstTypeName = ROOT_ZOD_NAME + (flag ? `__${capitalizeWords(flag, '__')}` : '');
			tsFileLines.push(`\t${flagName}: ${subConstTypeName},`);
		} else {
			tsFileLines.push(
				`\t${flagName}: ${flagTypescriptZodMethod(flag)}.default(${flagTypescriptDefaultValue(flag)}),`
			);
		}
	}
	tsFileLines.push(`});`);
	tsFileLines.push(`export type ${constName} = z.infer<typeof ${constName}>;`);
	tsFileLines.push('');

	return tsFileLines;
};

const generateGroups = (
	flags: Record<string, PersistentFlag>
): Map<string, Record<string, PersistentFlag | string>> => {
	const groups: Map<string, Record<string, PersistentFlag | string>> = new Map();

	for (const [key, flag] of Object.entries(flags)) {
		const keyParts = key.split('/');
		const name = keyParts.at(-1);
		const groupParts = keyParts.slice(0, -1);
		if (!name) continue;

		const groupName = groupParts.join('__');
		if (!groups.has(groupName)) groups.set(groupName, {});
		groups.get(groupName)![name] = flag;
		if (groupParts.length > 0) {
			const subGroupName = groupParts.slice(0, -1).join('__');
			if (!groups.has(subGroupName)) groups.set(subGroupName, {});
			groups.get(subGroupName)![groupParts.at(-1) || ''] = groupParts.join('__');
		}
	}

	return groups;
};

export const generateTSTypeFileContent = (
	flags: Record<string, PersistentFlag>,
	groupTypeHash: Map<string, string>
): string => {
	const groups = generateGroups(flags);

	// Generate TypeScript file content
	const tsFileContent: string[] = [
		'// This file is auto-generated by FlagFlow. Do not edit manually!',
		`// Created at: ${new Date().toISOString()}`,
		'',
		'',
		'// Group types'
	];

	for (const [groupName, groupFlags] of sortMapByKey(groups).entries())
		tsFileContent.push(...generateGroupTypeCode(groupName, groupFlags));

	tsFileContent.push('', '', '// Group default values as objects');
	for (const [groupName, groupFlags] of sortMapByKey(groups, true).entries())
		tsFileContent.push(...generateGroupDefaultObjectCode(groupName, groupFlags));

	tsFileContent.push('', '', '// Group hash checksums');
	for (const [groupName, groupHash] of groupTypeHash.entries()) {
		const typeName = ROOT_TYPE_NAME + (groupName ? `__${capitalizeWords(groupName, '__')}` : '');
		tsFileContent.push(`export const HASH_${typeName.toUpperCase()} = '${groupHash}';`);
	}

	tsFileContent.push('', '', '// Client type descriptors');
	tsFileContent.push('export type FlagFlow_DescriptorTypeMap = {');
	for (const groupName of [...groupTypeHash.keys()].toSorted()) {
		const typeKey = (groupName || '#root').replaceAll('__', '/');
		const typeName = ROOT_TYPE_NAME + (groupName ? `__${capitalizeWords(groupName, '__')}` : '');
		tsFileContent.push(`\t'${typeKey}': ${typeName};`);
	}
	tsFileContent.push('};');

	tsFileContent.push(`
export const flagFlow_Descriptors: {
	[K in keyof FlagFlow_DescriptorTypeMap]: {
		hash: string;
		uri: string;
	}
} = {`);
	for (const groupName of [...groupTypeHash.keys()].toSorted()) {
		const typeUri = groupName.replaceAll('__', '/');
		const typeKey = (groupName || '#root').replaceAll('__', '/');
		const typeName = ROOT_TYPE_NAME + (groupName ? `__${capitalizeWords(groupName, '__')}` : '');
		tsFileContent.push(`\t'${typeKey}': {`);
		tsFileContent.push(`\t\thash: HASH_${typeName.toUpperCase()},`);
		tsFileContent.push(`\t\turi: '${typeUri ? '/' + typeUri : ''}',`);
		tsFileContent.push(`\t},`);
	}
	tsFileContent.push(`} as const;`);
	tsFileContent.push('');

	return tsFileContent.join('\n');
};

export const generateTSZodFileContent = (flags: Record<string, PersistentFlag>): string => {
	const groups = generateGroups(flags);

	// Generate TypeScript file content
	const tsFileContent: string[] = [
		'// This file is auto-generated by FlagFlow. Do not edit manually!',
		`// Created at: ${new Date().toISOString()}`,
		'',
		'import { z } from "zod";',
		'',
		'',
		'// Group zod objects'
	];

	for (const [groupName, groupFlags] of sortMapByKey(groups, true).entries())
		tsFileContent.push(...generateGroupZodCode(groupName, groupFlags));

	tsFileContent.push('');

	return tsFileContent.join('\n');
};
