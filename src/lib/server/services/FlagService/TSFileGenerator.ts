/* eslint-disable unicorn/prefer-single-call */
import {
	flagTypescriptDefaultValue,
	flagTypescriptType,
	flagTypescriptZodMethod
} from '$lib/flagHandler/flagTypescript';
import { sortMapByKey, sortObjectByKey } from '$lib/objectEx';
import { capitalizeWords } from '$lib/stringEx';
import type { EtcdFlag } from '$types/etcd';

const ROOT_TYPE_NAME = 'FlagFlow';
const generateGroupTypeCode = (
	groupName: string,
	groupFlags: Record<string, EtcdFlag | string>
): string[] => {
	const tsFileLines: string[] = [];

	const typeName = ROOT_TYPE_NAME + (groupName ? `__${capitalizeWords(groupName, '__')}` : '');
	tsFileLines.push(`export type ${typeName} = {`);
	for (const [flagName, flag] of Object.entries(sortObjectByKey(groupFlags))) {
		if (typeof flag === 'string') {
			const subTypeName = ROOT_TYPE_NAME + (flag ? `__${capitalizeWords(flag, '__')}` : '');
			tsFileLines.push(`\treadonly ${flagName}: ${subTypeName};`);
		} else {
			tsFileLines.push(`\t/**`);
			if (flag.description) tsFileLines.push(`\t* ${flag.description}`);
			tsFileLines.push(`\t* @default ${flagTypescriptDefaultValue(flag)}`);
			tsFileLines.push(`\t*/`);
			tsFileLines.push(`\treadonly ${flagName}: ${flagTypescriptType(flag)};`);
		}
	}
	tsFileLines.push(`};`, '');

	return tsFileLines;
};

const ROOT_DEFAULTOBJECT_NAME = 'defaultFlagFlow';
const generateGroupDefaultObjectCode = (
	groupName: string,
	groupFlags: Record<string, EtcdFlag | string>
): string[] => {
	const tsFileLines: string[] = [];

	const typeName = ROOT_TYPE_NAME + (groupName ? `__${capitalizeWords(groupName, '__')}` : '');
	const constName =
		ROOT_DEFAULTOBJECT_NAME + (groupName ? `__${capitalizeWords(groupName, '__')}` : '');
	tsFileLines.push(`export const ${constName}: ${typeName} = {`);
	for (const [flagName, flag] of Object.entries(sortObjectByKey(groupFlags))) {
		if (typeof flag === 'string') {
			const subConstTypeName =
				ROOT_DEFAULTOBJECT_NAME + (flag ? `__${capitalizeWords(flag, '__')}` : '');
			tsFileLines.push(`\t${flagName}: ${subConstTypeName},`);
		} else {
			tsFileLines.push(`\t${flagName}: ${flagTypescriptDefaultValue(flag)},`);
		}
	}
	tsFileLines.push(`};`, '');

	return tsFileLines;
};

const ROOT_ZOD_NAME = 'FlagFlow';
const generateGroupZodCode = (
	groupName: string,
	groupFlags: Record<string, EtcdFlag | string>
): string[] => {
	const tsFileLines: string[] = [];

	const constName = ROOT_ZOD_NAME + (groupName ? `__${capitalizeWords(groupName, '__')}` : '');
	tsFileLines.push(`export const ${constName} = z.object({`);
	for (const [flagName, flag] of Object.entries(sortObjectByKey(groupFlags))) {
		if (typeof flag === 'string') {
			const subConstTypeName = ROOT_ZOD_NAME + (flag ? `__${capitalizeWords(flag, '__')}` : '');
			tsFileLines.push(`\t${flagName}: ${subConstTypeName},`);
		} else {
			tsFileLines.push(
				`\t${flagName}: ${flagTypescriptZodMethod(flag)}.default(${flagTypescriptDefaultValue(flag)}),`
			);
		}
	}
	tsFileLines.push(`});`);
	tsFileLines.push(`export type ${constName} = z.infer<typeof ${constName}>;`);
	tsFileLines.push('');

	return tsFileLines;
};

const generateGroups = (
	flags: Record<string, EtcdFlag>
): Map<string, Record<string, EtcdFlag | string>> => {
	const groups: Map<string, Record<string, EtcdFlag | string>> = new Map();

	for (const [key, flag] of Object.entries(flags)) {
		const keyParts = key.split('/');
		const name = keyParts.at(-1);
		const groupParts = keyParts.slice(0, -1);
		if (!name) continue;

		const groupName = groupParts.join('__');
		if (!groups.has(groupName)) groups.set(groupName, {});
		groups.get(groupName)![name] = flag;
		if (groupParts.length > 0) {
			const subGroupName = groupParts.slice(0, -1).join('__');
			if (!groups.has(subGroupName)) groups.set(subGroupName, {});
			groups.get(subGroupName)![groupParts.at(-1) || ''] = groupParts.join('__');
		}
	}

	return groups;
};

export const generateTSTypeFileContent = (
	flags: Record<string, EtcdFlag>,
	groupTypeHash: Map<string, string>
): string => {
	const groups = generateGroups(flags);

	// Generate TypeScript file content
	const tsFileContent: string[] = [];
	tsFileContent.push(
		'// This file is auto-generated by FlagFlow. Do not edit manually!',
		`// Created at: ${new Date().toISOString()}`
	);

	tsFileContent.push('', '', '// Group types');
	for (const [groupName, groupFlags] of sortMapByKey(groups).entries())
		tsFileContent.push(...generateGroupTypeCode(groupName, groupFlags));

	tsFileContent.push('', '', '// Group default values as objects');
	for (const [groupName, groupFlags] of sortMapByKey(groups, true).entries())
		tsFileContent.push(...generateGroupDefaultObjectCode(groupName, groupFlags));

	tsFileContent.push('', '', '// Group hash checksums');
	for (const [groupName, groupHash] of groupTypeHash.entries()) {
		const typeName = ROOT_TYPE_NAME + (groupName ? `__${capitalizeWords(groupName, '__')}` : '');
		tsFileContent.push(`export const HASH_${typeName.toUpperCase()} = '${groupHash}';`);
	}

	tsFileContent.push('', '', '// Client type descriptors');
	tsFileContent.push('export type FlagFlow_DescriptorTypeMap = {');
	for (const groupName of [...groupTypeHash.keys()].sort()) {
		const typeKey = (groupName || '#root').replaceAll('__', '/');
		const typeName = ROOT_TYPE_NAME + (groupName ? `__${capitalizeWords(groupName, '__')}` : '');
		tsFileContent.push(`\t'${typeKey}': ${typeName};`);
	}
	tsFileContent.push('};');

	tsFileContent.push(`
export const flagFlow_Descriptors: {
	[K in keyof FlagFlow_DescriptorTypeMap]: {
		hash: string;
		uri: string;
	}
} = {`);
	for (const groupName of [...groupTypeHash.keys()].sort()) {
		const typeUri = groupName.replaceAll('__', '/');
		const typeKey = (groupName || '#root').replaceAll('__', '/');
		const typeName = ROOT_TYPE_NAME + (groupName ? `__${capitalizeWords(groupName, '__')}` : '');
		tsFileContent.push(`\t'${typeKey}': {`);
		tsFileContent.push(`\t\thash: HASH_${typeName.toUpperCase()},`);
		tsFileContent.push(`\t\turi: '${typeUri ? '/' + typeUri : ''}',`);
		tsFileContent.push(`\t},`);
	}
	tsFileContent.push(`} as const;`);

	tsFileContent.push(
		'',
		'',
		'// Example code with Axios',
		'// Always copy the latest version of this file to your client codebase',
		'// Use the proper level of functions'
	);
	tsFileContent.push(`
/*
// flagflowFetchData.ts
import axios from "axios";

import { flagFlow_Descriptors, FlagFlow_DescriptorTypeMap } from "./flagflowTypes";

const FLAGFLOW_BASE_URL = 'http://localhost:5173/flags';
export const fetchData = async <K extends keyof FlagFlow_DescriptorTypeMap>(
    key: K
): Promise<FlagFlow_DescriptorTypeMap[K]> => {
    const { uri, hash } = flagFlow_Descriptors[key];
    const { data } = await axios.get<FlagFlow_DescriptorTypeMap[K]>(
        FLAGFLOW_BASE_URL + uri, {
        responseType: 'json',
        headers: {
            'Content-Type': 'application/json',
            'x-accept-flaggroup-hash': hash,
        }
    })
    return data
}

export const createFetchFunction = <K extends keyof FlagFlow_DescriptorTypeMap>(
    key: K
): (() => Promise<FlagFlow_DescriptorTypeMap[K]>) => () => fetchData(key);

export const createFetchFunctionWithCache = <K extends keyof FlagFlow_DescriptorTypeMap>(
    key: K,
    ttlSeconds: number = 60
) => {
    const fetchDataFn = createFetchFunction(key);
    let data: FlagFlow_DescriptorTypeMap[K] | undefined;
    let lastFetchTime: number = 0;
    return async (): Promise<FlagFlow_DescriptorTypeMap[K]> => {
        const now = Date.now();
        if (data && (now - lastFetchTime < ttlSeconds * 1000)) return data;

        data = await fetchDataFn();
        lastFetchTime = now;
        return data;
    }
}

// yourService.ts
    import { createFetchFunction, createFetchFunctionWithCache, fetchData } from "flagflowFetchData";

    ...

    // direct fetch
    const data1 = await fetchData('#root');

    // create fetch data function and call it to get data
    const fetchFn = createFetchFunction('#root');
    const data2 = await fetchFn();

    // create fetch data function with cache and call it to get data
    const cachedFetchFn = createFetchFunctionWithCache('#root', 30);
    const data3 = await cachedFetchFn();

    ...

*/
`);

	tsFileContent.push('');

	return tsFileContent.join('\n');
};

export const generateTSZodFileContent = (flags: Record<string, EtcdFlag>): string => {
	const groups = generateGroups(flags);

	// Generate TypeScript file content
	const tsFileContent: string[] = [];
	tsFileContent.push(
		'// This file is auto-generated by FlagFlow. Do not edit manually!',
		`// Created at: ${new Date().toISOString()}`
	);
	tsFileContent.push('', 'import { z } from "zod";');

	tsFileContent.push('', '', '// Group zod objects');
	for (const [groupName, groupFlags] of sortMapByKey(groups, true).entries())
		tsFileContent.push(...generateGroupZodCode(groupName, groupFlags));

	tsFileContent.push('');

	return tsFileContent.join('\n');
};
