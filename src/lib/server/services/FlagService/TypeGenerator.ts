import { sortMapByKey, sortObjectByKey } from '$lib/objectEx';
import { capitalizeWords } from '$lib/stringEx';
import type { EtcdFlag } from '$types/etcd';

export type FlagTypeDescriptor = {
	tsFileContent: string;
	groupTypeHash: Map<string, string>;
};

export const generateTypeDescriptor = (flags: Record<string, EtcdFlag>): FlagTypeDescriptor => {
	const groups: Map<string, Record<string, EtcdFlag | string>> = new Map();

	const startTime = Date.now();
	for (const [key, flag] of Object.entries(flags)) {
		const keyParts = key.split('/');
		const name = keyParts.at(-1);
		const groupParts = keyParts.slice(0, -1);
		if (!name) continue;

		const groupName = groupParts.join('_');
		if (!groups.has(groupName)) groups.set(groupName, {});
		groups.get(groupName)![name] = flag;
		if (groupParts.length > 0) {
			const subGroupName = groupParts.slice(0, -1).join('_');
			if (!groups.has(subGroupName)) groups.set(subGroupName, {});
			groups.get(subGroupName)![groupParts.at(-1) || ''] = groupParts.join('_');
		}
	}
	const elapsedTime = Date.now() - startTime;

	const ROOT_TYPE_NAME = 'FlagFlow';
	const tsFileContent: string[] = [];
	tsFileContent.push(
		'// This file is auto-generated by FlagFlow. Do not edit manually!',
		`// Created at: ${new Date().toISOString()} in ${elapsedTime + 1}ms`,
		''
	);
	for (const [groupName, groupFlags] of sortMapByKey(groups).entries()) {
		const typeName = ROOT_TYPE_NAME + (groupName ? `_${capitalizeWords(groupName, '_')}` : '');
		tsFileContent.push(`export type ${typeName} = {`);
		for (const [flagName, flag] of Object.entries(sortObjectByKey(groupFlags))) {
			if (typeof flag === 'string') {
				const subTypeName = ROOT_TYPE_NAME + (flag ? `_${capitalizeWords(flag, '_')}` : '');
				tsFileContent.push(`\t${flagName}: ${subTypeName};`);
			} else {
				const type = flag.valueExists
					? 'string | number | boolean'
					: 'string | number | boolean | undefined';
				tsFileContent.push(`\t${flagName}: ${type};`);
			}
		}
		tsFileContent.push(`};`, '');
	}

	return {
		tsFileContent: tsFileContent.join('\n'),
		groupTypeHash: new Map<string, string>([])
	};
};
